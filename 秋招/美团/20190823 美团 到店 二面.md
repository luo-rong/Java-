## 项目
#### ==1. 难点==

#### 2. 解释：低耦合性、可扩展性、可复用性
1. 低耦合性：高内聚低耦合，是软件工程中的概念，是判断软件设计好坏的标准，主要用于程序的面向对象的设计，主要看类的内聚性是否高，耦合度是否低。目的是使程序模块的可重用性、移植性大大增强。通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系；耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据
2. 可扩展性（可伸缩性）：一种对软件系统计算处理能力的设计指标，高可伸缩性代表一种弹性，在系统扩展成长过程中，软件能够保证旺盛的生命力，通过很少的改动甚至只是硬件设备的添置，就能实现整个系统处理能力的线性增长，实现高吞吐量和低延迟高性能
3. 可复用性：复用的好处可以得到较高的生产效率以及随之而来的成本降低、较高的软件质量（错误可以更快的被纠正）以及恰当的使用复用可以改善系统的可维护性

## Java
#### 1. 常用集合类
集合 | 底层结构 | 存储类型 | 长度是否有上限 | 扩增/大小 | 线程安全 | 性能 | 备注
---|---|---|---|---|---|---|---
ArrayList | 数组 | 随机 | 有，`int hugeCapacity()` | 自动扩增/1.5倍 | 不安全 | 查询性能好 |
Vector | 数组 | 随机 | 有，`int hugeCapacity()` | 自动扩增/2倍 | 安全 | |
Stack | 数组 | 随机 | 有，`int hugeCapacity()` | 自动扩增/2倍 | 安全 | | 继承自Vector
LinkedList | 双向链表 | 顺序 | 无，直到内存满 | | 不安全 | 增加性能好 |
HashMap | | | 有，`MAXIMUM_CAPACITY = 1<<30` | 自动扩增/2倍 | 不安全 | |

#### 2. `ArrayList`的实现，为什么查找效率高
`ArrayList`采用数组数组实现。查找效率高，因为`ArrayList`是连续存放元素的，找到第一个元素的首地址，再加上每个元素的占据的字节大小就能定位到对应的元素

#### 3. `ThreadPoolExcutor()`创建线程池的主要参数

```java
new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);
```

1. `corePoolSize`：线程池的基本大小。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的`prestartAllCoreThreads()`方法，线程池会提前创建并启动所有基本线程
2. `runnableTaskQueue`：任务队列。用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列
    1. `ArrayBlockingQueue`：基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序
    2. `LinkedBlockingQueue`：基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列
    3. `SynchronousQueue`：不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列
    4. `PriorityBlockingQueue`：具有优先级的无限阻塞队列
3. `maximumPoolSize`：线程池最大数量。线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果
4. `ThreadFactory`：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架`guava`提供的`ThreadFactoryBuilder`可以快速给线程池里的线程设置有意义的名字
5. `RejectedExecutionHandler`：饱和策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是`AbortPolicy`，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略：
    1. `AbortPolicy`：直接抛出异常
    2. `CallerRunsPolicy`：只用调用者所在线程来运行任务
    3. `DiscardOldestPolicy`：丢弃队列里最近的一个任务，并执行当前任务
    4. `DiscardPolicy`：不处理，丢弃掉

#### 4. Java中的锁有几种
1. `synchronized`关键字
2. `java.util.concurrent.locks`包下常用的类
    1. `ReentrantLock`：可重入锁，实现了`Lock`接口，并且提供了更多的方法
    2. `ReentrantReadWriteLock`：可重入的读写锁，实现了`ReadWriteLock`接口，最主要的有两个方法：`readLock()`和`writeLock()`用来获取读锁和写锁
    3. `StampedLock`：JDK8新增，该锁提供了三种模式的读写控制
        1. 写锁writeLock，是个排它锁或者叫独占锁
        2. 悲观读锁readLock，是个共享锁
        3. 乐观读锁tryOptimisticRead（在操作数据前并没有通过CAS设置锁的状态）

## Spring
#### ~~1. AOP的实现~~

#### ==2. AOP的使用限制==

#### 3. AOP的使用场景
[AOP的应用场景(异常处理、安全检查和缓存)](https://blog.csdn.net/lzufeng/article/details/89816281)

[Principle of Spring AOP Implementation](https://programmer.help/blogs/principle-of-spring-aop-implementation.html)
1. 异常处理
2. 安全检查
3. 缓存


## JVM
#### 1. `A a = new A()`的执行过程，内存分配的方式
虚拟机遇到一条`new`指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并且检查代表这个符号引用的类是否已经被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载。

在类加载检查通过后，接下来虚拟机将会为新生的对象分配内存。对象所需的内存大小在类加载完成后就可以确定，为对象分配空间的任务等同于把一块大小确定的内存从Java堆中划分出来。内存分配有两种方式：

1. 指针碰撞：假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器。分配内存时就把指针向空闲空间那边挪动一段与对象大小相等的距离。一些新生代GC收集器使用的是复制算法，所以采用指针碰撞方式分配内存
2. 空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录。老年代垃圾收集器使用了标记清理、整理算法，所以配合空闲列表方式分配内存

#### ~~2. JVM内存模型~~

#### 3. 垃圾收集器
[深入理解JVM(3)——7种垃圾收集器](https://crowhawk.github.io/2017/08/15/jvm_3/)

![image](https://pic.yupoo.com/crowhawk/56a02e55/3b3c42d2.jpg)

如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。Hotspot实现了如此多的收集器，正是因为目前并无完美的收集器出现，只是选择对具体应用最适合的收集器

收集器 | 执行方式 | 适用分代 | 算法 | 目标 | 适用场景
---|---|---|---|---|--- 
Serial | 串行 | 新生代 | 复制算法 | 响应速度优先 | 单CPU环境下的Client模式
Serial Old | 串行 | 老年代 | 标记-整理 | 响应速度优先 | 单CPU环境下的Client模式、CMS的后备预案
ParNew | 并行 | 新生代 | 复制算法 | 响应速度优先 | 多CPU环境时在Server模式下与CMS配合
Parallel Scavenge | 并行 | 新生代 | 复制算法 | 吞吐量优先 | 在后台运算而不需要太多交互的任务
Parallel Old | 并行 | 老年代 | 标记-整理 | 吞吐量优先 | 在后台运算而不需要太多交互的任务
CMS | 并发 | 老年代 | 标记-清除 | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用
G1 | 并发 | both | 标记-整理+复制算法 | 响应速度优先 | 面向服务端应用，将来替换CMS

#### ~~4. 垃圾收集算法~~

## 数据库
#### ~~1. 索引类别~~

#### ~~2. 索引的数据结构~~

#### 3. 索引命中后的查找对应行的过程
[MySQL优化：如何避免回表查询？什么是索引覆盖？](https://www.cnblogs.com/myseries/p/11265849.html)

> InnoDB有两大类索引，聚集索引（clustered index）、普通索引（secondary index）。InnoDB普通索引的叶子节点存储主键值。InnoDB聚集索引的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引：
> 1. 如果表定义了PK，则PK就是聚集索引
> 2. 如果表没有定义PK，则第一个not NULL unique列是聚集索引
> 3. 否则，InnoDB会创建一个隐藏的row-id作为聚集索引

1. 回表查询：从普通索引无法直接定位行记录，需要回表查询，先定位主键值，再定位行记录，通常情况下，需要扫码两遍索引树，性能较扫一遍索引树更低

![image](https://img2018.cnblogs.com/blog/885859/201907/885859-20190729184911699-676257427.png)

2. 覆盖索引：只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。常见的实现方法是：将被查询的字段，建立到联合索引里去（索引叶子节点存储了主键id）

#### ~~4. 事务隔离级别和可能的问题~~

## 算法
#### 1. 常见排序算法
![image](https://upload-images.jianshu.io/upload_images/1156494-62f859c2ac6f95ff.png)

## 设计模式
#### ==1. 了解的设计模式==

## 设计题
#### 1. 设计一个路由，为编号为1、2、3、4、5的五台服务器分配流量，期望比例为1：2：3：3：1
1. 方法1：利用随机数生成对应的服务器编号：`routeNum = (1/3)*random(1,5)+(1/3)*random(2,4)+(1/3)*random(3,4)`其中`random(n,m) = random(m-n)+n`表示随机生成`[n,m]`区间内的数字
2. 方法2：根据当前流量比例动态选择当前请求对应服务器编号

## 操作系统
#### ==1. 线程状态及转换，从runnable到running（wait/sleep）==


## 其他
1. 了解其他技术