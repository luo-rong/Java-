# HR面
1. 公司选择
2. 薪资期望
3. 职业规划


---
# 技术一面
## 操作系统
1. ==内存管理==
2. ==虚拟内存管理==

## 网络
#### 1. TCP连接，其中一端断电会如何
1. TCP连接双方定时发握手消息
2. 利用TCP协议栈中的KeepAlive探测


## 数据库
#### 1. 事务的特性
1. 原子性：Atomicity，一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样
2. 一致性：Consistency，在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作
3. 隔离性：Isolation，数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交、读提交、可重复读和串行化
4. 持续性/永久性：Durability，事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

#### 1. 事务隔离级别
隔离级别\问题 | 脏读 | 不可重复读 | 幻读
---|---|---|---|--- 
未提交读 | 可能 | 可能 | 可能
已提交读 | 可能 |可能  | 可能
可重复读 | 不可能 | 不可能| 可能
可串行化 | 可能 |不可能 |不可能

1. 事务隔离级别
    1. 未提交读：Read Uncommitted，允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
    2. 已提交读：Read Committed，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别
    3. 可重复读：Repeated Read，在同一个事务内的查询都是事务开始时刻一致的。InnoDB默认级别
    4. 可串行化：Serializable，完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞
2. 可能产生的问题
    1. 脏读：Dirty Read，脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据
    2. 不可重复读：NonRepeatable Read，是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读
    3. 幻读：Phantom Read，是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样


## 数据结构
#### ==1. 二叉树最长路径==

## 算法
#### ==1. 最长升序子列==
#### ==2. 笔试题==

## Spring
#### ~~1. IOC~~

## 场景题
#### 1. 设计Java读写锁

## 智力题
#### ==1. 8个球一个重，天平2次找到==

---
# 技术二面
## 算法
#### 1. ==笔试第二题==
#### 2. ==找数组中三个数的最小方差==
#### 3. ==1亿手机号排序==

## 网络
#### 1. ==TCP四次挥手，如果去掉第一次ACK，只保留三次握手可以么==

## JVM
#### 1. 垃圾回收是否有内存泄漏的风险
[ThreadLocal原理及内存泄露预防](https://blog.csdn.net/puppylpg/article/details/80433271)

#### 2. 强引用、弱引用、软引用、虚引用
[理解Java的强引用、软引用、弱引用和虚引用](https://juejin.im/post/5b82c02df265da436152f5ad#heading-4)

引用类型 | GC回收 | 用途 | 生存时间
---|---|---|---|---
强引用 | 从来不会 | 对象的一般状态 | JVM停止运行时终止
软引用 | 当内存不足时 | 对象缓存 | 内存不足时终止
弱引用 | 正常垃圾回收时 | 对象缓存 | 垃圾回收后终止
虚引用 | 正常垃圾回收时 | 跟踪对象的垃圾回收 | 垃圾回收后终止

1. 强引用：StrongReference，使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它
    
    ```java
    Object strongReference = new Object();
    ```
    
2. 软引用：SoftReference，如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存
    
    ```java
    // 强引用
    String strongReference = new String("abc");
    // 软引用
    String str = new String("abc");
    SoftReference<String> softReference = new SoftReference<String>(str);
    ```
    
3. 弱引用：WeakReference，弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象
    
    ```java
    String str = new String("abc");
    WeakReference<String> weakReference = new WeakReference<>(str);
    str = null;
    ```
    
4. 虚引用：PhantomReference，虚引用顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动

    虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

    ```java
    String str = new String("abc");
    ReferenceQueue queue = new ReferenceQueue();
    // 创建虚引用，要求必须与一个引用队列关联
    PhantomReference pr = new PhantomReference(str, queue);
    ```


## 数据库
#### ~~1. 事务隔离级别~~
#### ==2. 乐观锁悲观锁==
#### 3. ==CAS的ABA问题==
#### 4. ==索引==